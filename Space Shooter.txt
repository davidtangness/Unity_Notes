Unity Tutorial - Space Shooter

In this tutorial we will create a top-down scrolling shooter. The biggest difference between this tutorial and Roll-a-ball is that we will be using imported assets rather than primitive shapes.

SETTING UP THE PROJECT

After creating a new blank project, the first thing we want to do is import the assets we'll be using for this project (the model for our player-controlled ship, etc). We'll get these from the Unity asset store. Oddly, I had to turn off "Use direct3d" in my project settings in order to actually view the store - otherwise it displays a blank screen on Unity's built-in browser. Apparently this is a widespread problem.

In this case, the import process is very simple. On unity's asset store website (https://www.assetstore.unity3d.com/en/#!/content/13866) you find the package you want, press "Open in Unity", which opens up the same page in Unity's browser. Presumably you could also browse the store from inside Unity to skip this step. Anyways, then you hit "download" and Unity pops up a hierarchical list of every asset in the package - you choose what you want and press Start, and Unity handles the rest.

Next we save our scene... nothing interesting here.

Next we set our build target to Web Player, as we did with Roll-a-ball.

Last, we go into Edit -> Project Settings -> Player and set resolution to 600x900. Then change the Game-view layout to Web so that we get an accurate representation of what the player would see in their web browser.


SETTING UP THE PLAYER

Drag our player-ship GameObject from the Assets->Models view into the Hierarchy.

Currently the player ship only has a few components - a Transform which controls its position and orientation, a Mesh and Mesh Renderer determining its shape and lighting, and a pair of shaders determining the appearance of that shape's "skin." 

We want our ship to be movable and collidable according to physics, so we'll attach a Rigidbody component. We don't want the ship to fall according to gravity, so we'll deselect "Use Gravity." 

Unlike in Roll-a-ball, where the player phere was a "primitive" which Unity intrinsicaly understood, Unity does not know how to handle collisions with our custom-made player ship. We need to tell Unity the shape of our ship by manually attaching a "collider" component. Specifically a "capsule collider" which is basically a cylinder with a sphere at either end. We can resize the spheres and pull them apart to fit nicely around our ship.

Capsule is one of several "primitive" colliders which Unity understands, but of course it wo't perfectly fit every object. Another option would be a "composite collider" which is a set of several primitive colliders all attached to the same object in slightly different positions. A third option is the "mesh collider" which detects collisions precicely according to the object's mesh. This is very performance-intensive, but can be improved by simplifying the mesh. The mesh collider and mesh renderer are allowed to used different meshes.

Colllisions in this game only need to trigger events, not bounce the ship off other objects, so we'll set the mesh collider to be a trigger collider.

Lastly, we'll add the prefab "engines_player" Particle System gameobject as a child of our player object. The transform of a child object is always relative to the parent's transform, so the engine flare will stay attached to our ship exactly as we want.



CAMERA AND LIGHTS

By default, Unity places the camera on the origin "behind" the origin, on the same horizontal plane. We want the camera to be aboe the ship looking own, so we'll reset its postion to origin, add some y-axis transform, and rotate it about the X-axis. 

There are two subtly-different options for camera projection, "orthographic" and "perspective". Perspective simulates the human eye, seeing everything within a certain angle from a single point. Orthographic does not use a field-of-view, rather it displays everything "as is" within a square whose size we can control. If perspective is an infinitely-long cone, orthographic is an infinitely-long cube. For this project we'll be using orthographic style, to emulate the arcade space shooters of yore. Tune the camera's orthographic size and transform until it feels right. I increased the size (effectively zooming out) and moved the camera ahead of the ship).

As part of the camera gameobject, we can set the background of the scene. For now, set it to solid black. Notice how we can still see the ship even on a black background with no lights? This is due to the default "ambient lighting" feture under Edit -> Render Settings. By default this is a dark grey, which gives a dim undirectional light to every object in the scene. We can hide this light by setting it to solid black.

We'll create three lights: main, fill and rim. We want the main light to emulate a sun, so we'll rotate it about the x and y axes to shine on the ship from one side, slightly above and ahead. Set the color to white and increate the intensity, to emulate a sun. The fill light should show the opposite side of the ship, so we'll give it an opposite rotation on the y-axis. We want this light to be subtle, so we'll cut its intensity and change it from white to a light blue.  Now we have two lights above and in front of the ship, so we want a rim light behind and below the ship to balance it out. Again, this should be subtle so cut its intensity even further and use a light blue color. Lastly, we'll organize our lights by making them children of an empty gameobject, resetting the transform and moving it out of the way. Moving the parent gameobject will not affect the look of our lighting, because "directional" lights light the entire scene based only on rotation.


ADDING A BACKGROUND

Currently the background for our game is flat black, which we want to replace with something more interesting. First, we will create a "Quad" gameobject which will hold our background. This is essentially a single-sided square formed by two triangles (whereas a "Plane" may be made of many more triangles... don't ask me why.). We'll move our quad to the origin and rotate it about the X-axis, so that it can be seen from above. We won't need this quad to be a collider so we can remove that default component.

To make the Quad interesting to look at, we will need to apply a texture. Some textures are included in the premade assets for this project, and the one we want is "tile_nebula_green_dff." For unity to apply a texture, it must make a "material" out of that texture, and then use that material in the Mesh Renderer component of the quad. Simply dragging an image from the Assets view onto the quad in the Scene view will do all of this automatically. 

By default, the entire image will be resized to fit on the quad, which can make it look squashed if the image has a different shape than the quad. To fix that, we should scale up the quad until it fills our game-view and fits the proportions of the image. We can see that the image we are using has a resolution of 1024x2048, so whatever scale we apply to the quad should follow that 1:2 ratio in order to keep the image undistorted. Use whatever scale makes the image fill your game view, which for me was 16x32.

Next, we want to make the background a bit brighter. By default Unity applies the "diffuse" shader, which is matte rather than glossy. The directional lights in our scene shine onto the background at a very shallow angles, and this combined with the matte shader mean the background is very dark. We don't want to change the existing lights as they already suit our ship, and it would be wasteful to add new unique lights on a separate layer just to hit this one quad. It is most efficient to just change the material shader being used for the background image. For this image, we really don't want or need any special lighting, we just want the image to appear exactly as it was created: change the shader from Diffuse to Unlit->Texture.

Lastly, notice that the player ship is currently buried halfway through the background quad, because both of them are at origin. We'll move the background quad down the Y-axis a few units to get it out of the way. Thanks to our orthographic camera, the Y-axis position of the ship and background will not affect how they look to the player.


MOVING THE PLAYER

To get our player ship moving, we need to attach a script to the Player gameobject much like we did for Roll-a-ball. Select the Player gameobject, click "Add Component" -> "New Script", and make it a C# script called "PlayerController". We'll edit the script in Unity's MonoDevelop environment, by double-clicking on the script.

Now, we want the player to move according to physics, much like we did with Roll-a-ball. When the player presses a key left or right, a force should push the ship left or right. These actions should be performed whenever Unity's physics engine updates, so we will place these actions in the "FixedUpdate()" function.

The following code snippet will give us the results of whatever input method is set up in Unity's input manager. By default, inputs are mapped to the WASD keys.

		float moveHorizontal = Input.GetAxis ("Horizontal");
		float moveVertical = Input.GetAxis ("Vertical");

The next code snippet maps those inputs to a Vector3 object which can be understood by our Player gameobject's RigidBody component. We put 0.0f in the y-axis because we do not want the ship to move on that axis.

		Vector3 movement = new Vector3 (moveHorizontal, 0.0f, moveVertical);
		rigidbody.velocity = movement;


Back in Unity, we can press play and see that our ship moves.. albeit slowly. We want to control the speed of our ship, so we'll go back to the script and add a public global variable named "speed." SInce this is a public variable, we will be able to set its value in the Inspector view in Unity. Now we need to apply speed to our ship's movement.

		rigidbody.velocity = movement * speed;

One quick note: unlike in Roll-a-ball we do not need to multiply by Time.deltaTime to remove the factor of the player's framerate. In Space Shooter, we are directly setting the player ship's velocity rather than imparting a force. If a user holds down their "A" key for a full second at 10 FPS versus 60 FPS, we'll simply be re-setting the velocity to the same value 10 or 60 times during that second... which has no effect regardless of frequency. In Roll-a-ball, we applied physical forces rather than directly setting a velocity, and so every repeated application of force would further increase the object's speed. One second with 60 pushes per second would move the object much faster than 10 pushes per second, unless we balance the size of each push by using Time.deltaTime.


Testing again, we notice that our ship is able to move off the edges of the screen, because we never constrained it. Back in our script, we'll declare four more public global variables: xMin, xMax, zMin and zMax, which will represent the edges of the player's movement space. In our FixedUpdate() function, once we've determined where the player wants to move we need to ensure that the ships actual position does not go beyond those boundaries. We can do so with the following code snippet:

		rigidbody.position = new Vector3 
		(
			Mathf.Clamp(rigidbody.position.x, xMin, xMax), 
			0.0f, 
			Mathf.Clamp(rigidbody.position.z, zMin, zMax)
		);

The Mathf.Clamp function above takes a number, a minimum and a maximum. If the number is between minimum and maximum, the number is returned. If the number is above max, max is return and if below min, min is returned. 

So now we can restrict the movement of our player ship, great. However, eventually we will want to apply those same restrictions to other objects, and in Unity's Inspect view those four public variables are taking up a lot of space. To make this code reusable and get it out of the way, we'll put these variables into their own "Boundary" class, create an instance of Boundary in the PlayerController class, and reference those variables through the instance.

	public class Boundary {
		public float xMin, xMax, zMin, zMax;
	}

	...

	public Boundary boundary;

	...

	rigidbody.position = new Vector3 
			(
				Mathf.Clamp(rigidbody.position.x, boundary.xMin, boundary.xMax), 
				0.0f, 
				Mathf.Clamp(rigidbody.position.z, boundary.zMin, boundary.zMax)
			);

Now, when we switch back to the Unity inspector, we cannot see the Boundary class or its public variables, meaning we cannot set them. We cannot see them because the Boundary class is not serialized... meaning the data from that class is not given to the Inspector. The default PlayerController class inherits its own serialized stats from MonoBehaviour, but for our custom Boundary class we must add that status manually, like so:

	[System.Serializable]
	public class Boundary {
		...


Returning to the Unity inspector, we see a "Boundary" tab in the Player Controller component, which we can expand to find XMin, XMax, ZMin and ZMax. As for their values, I went with -6, 6, -4 and 8. Testing the game shows that the ship now stops at those boundaries.


Finally, we'll add some tilt when the ship moves on the X-axis, as if the ship were banking. In the PlayerController script, we'll add a public tile variable, and a new snipped to the end of FixedUpdate()

	rigidbody.rotation = Quaternion.Euler (0.0f, 0.0f, rigidbody.velocity.x * -tilt);

"Quaternion" is Unity's internal method of storing and processing angles, and uses four values (X, Y, Z and W) and which I cannot intuitively picture in my head. "Euler" translates that angle into the more comfortable Euler format (X, Y, and Z) which is what we normally use in Unity's Inspector view. Euler format suffers some issues ("Gimbal Lock") when used continuously to calculate changes in angle, which is why Unity converts back to Quaternion for its own processing... but the full explanation requires some hardcore math which I cannot deal with at this time of night. Anyways, we specify a Euler angle with no rotation on the X and Y axes, and rotate about the Z axis according to the direction our ship is moving. Back in the Inspector I set tilt = 4, and in testing it looks good.


CREATING SHOTS

Our player ship needs to be able to shoot at enemies, so have to create shots.

We'll start with an empty gameobject named "Bolt" which will be the parent for both the logical and visual portions of our shots. This way, we can reuse the logic for different types of weapons while replacing the visuals.

Next we'll create the visual portion, by creating a Quad as a child of Bolt, and rotating that quad about the X-axis so that it faces up towards the camera. Then we need to apply a texture to the quad, but we do not want to let Unity create a default material for the texture this time. 

We'll create a new material in the Materials folder, by right-clicking in the assets view and selecting Create->Material. Then with the new material open in the Inspector view, we'll drag the texture fx_lazer_orange from the Textures directory onto the texture slot of the material in the Inspector. Now simply drag our material onto the VFX quad which we created earlier. 

In the game view, our shot looks like a bright bolt on a flat black square, which is not what we want. We want the black to become transparent. We can achieve this by switching the VFX mesh renderer's shader from "Diffuse" to "Particles->Additive". When the additive shader is used, Black is left out of the scene and White is strengthened, and then all other colors are added on top. This will get rid of the black square and make our bolt stand out very clearly. Note, "Mobile" shaders are generally more efficient but may lose some customization or visual quality. But for our game, the mobile additive shader looks fine.

Now for movement and collision. First we'll add a RigidBody component and deselect gravity, because we don't want the shot to fall through the background. Next, in the VFX quad, notice how a Mesh Collider is already present. Quads are created by default with a mesh collider, but we don't want one here. The quad is much larger than the actual shot that we want, so using a mesh collider on the quad would lead to collisions even when the shot appears to miss. So we'll remove the Mesh Collider component from VFX.

So the collider we really want is a Capsule Collider, scaled to the size and shape of our bolt. We'll add this component to the Bolt gameobject, then rotate and and scale it by eye. I set it to run along the Z-Axis, with radius 0.035 and height 0.55.

Finally we need to create our logic, in a script component. For now, we just want our bolt to move forward as soon as it is fired... meaning as soon as a copy of Bolt is created. We can achieve this by simply setting the RigidBody's velocity to "transform.forward" in the Start() function. Transform.forward will move the object along its local Z-axis without moving on X or Y, and that is exactly what we want. To let us tune the speed of the bolt, we add a public "speed" variable and multiply the velocity by it.

	public float speed;

	...

	void Start () {
		rigidbody.velocity = transform.forward * speed;
	}

Test it and choose a comfortable speed value, I went with 15. Note that because we are setting the velocity directly rather than imparting a physical force, the player's framerate will not affect the movement of the bolt... meaning we don't need to multiply by Time.deltaTime.

We will want to make many copies of Bolt eventually, so well save it as a Prefab by dragging "Bolt" into the Prefabs folder in the assets view. And we only want a bolt to be created when the player fires, so we should delete the original bolt from the scene.

A cool trick to test our Bolts even without any firing code is to launch the game, and then drag the Bolt prefab into the hierarchy view. This will create temporary instances of Bolt within our game, which disappear from the hierarchy when we stop playing.


SHOOTING SHOTS