Roll-a-ball is a game where the player rolls a ball around on a plane using physics simulation controlled by the keyboard. The goal is to pick up a number of objects on the plane by rolling into them. An on-screen counter tracks the number of objects picked up, and the game ends when all objects have been picked up.




INITIAL SETUP


The directories "Library" and "Temp" are generated by Unity automatically and can be ignored for version-control. Here is a simple .gitignore:

	=============== 
	Unity generated
	===============
	Temp/
	Library/

	=====================================
	Visual Studio / MonoDevelop generated
	=====================================
	ExportedObj/
	obj/
	*.svd
	*.userprefs
	/*.csproj
	*.pidb
	*.suo
	/*.sln
	*.user
	*.unityproj
	*.booproj




Unity has "projects," "scenes" analogous to "games," "levels." Roll-a-ball is one project with one scene.

"GameObjects" are the things which a player sees/hears in a scene. 2D and 3D objects, UI, lighting, audio, etc. 



SCENE SETUP (Board, Player and Lighting)

The first GameObject we create is a plane, which acts as our game board. on which the ball will roll. For convenience, we set the position of the plane the origin 0/0/0 (X/Y/Z) which puts it in the absolute center of the scene. Planes can be scaled by length and width in terms of "unity units", but have no height. They are also one-sided, and we can reverse the facing side by setting height to a negative number.

Now we create another game object, a sphere representing our player. The sphere is a "primitive object," meaning it is built-in to Unity and thus we don't need to define it. In unity, primiitive objects are 1x1x1, and the sphere defaults to be halfway through our ground plane. We move it up the Y-axis by half a unit to make it sit on the ground.

Next we create a main light at 30/60/0 with shadows enabled so that we get a light shining from above and one side and causing the ball to case a shadow. We then add a fill light with a bit of colour, a lower intensity and rotation -30/-60/0 (ie 330/300/0) so that the ball has a bit of light case from below, separating it from its shadow. The combination of these two lights make the ball easier to see against the ground.

We can create an empty GameObject to hold both lights. This creates a Parent/Child hierarcy, and we can modify some properties of the parent to modify all of the children simultaneously. In our game, we will move all of the lights to position 0/50/0 which gets them out of the way. It does not change the actual appearance of the in-game lighting, because the lighting tech we're using is too simple. More on that later (probably).



MOVING THE PLAYER

We want the Player GameObject to behave like a solid object with physics. First, we have to attach a "Rigidbody Component" to Player.

Next, we want to allow player input to control the sphere. We will do this by attaching a script. We want this script to act as a component of Player, and we can shortcut setting up this script by first selecting Player and then pressing "Add Component -> New Script" in the Inspector view. This creates the script file at the top level of our Assets folder, so we'll have to move it to the place we want it to be.

Unity comes attached to a coding environment "MonoDevelop"

Within the script, we want to check for player input on every frame, and then apply movement on every frame in response. Unity calls "Update()" every frame. "fixedUpdate()" is called just before performing physics calculations, but physics calculations don't necessarily occur every frame. We want to deal with the player's rigidbody movement which is physics, so we'll put that in fixedUpdate().

We need to use the Input class. 

"Ctrl '" searches the unity documentation for the highlighted text... in this case the Input class.

The API tells us that movement should be read through Input.GetAxis which can be mapped to a keyboard, mouse, etc in the "Input Manager" section of "Project Details" in Unity. This function returns movement as a float on the axes "Horizontal" and "Vertical".

Now we use the "AddForce" method for our RigidBody object. This takes a Vector3 (ie a set of three floats) representing the force to add on the x, y and z axes. We want to move on the x and z axes, so we use x = Input.GetAxis("horizontal"), y = 0, z = InputGetAxis("vertical").


Because forces are being read/applied every frame, the result of some amount of input will depend on the user's framerate. That's bad. We can eliminate this by using "Time.deltaTime" as a coefficient when we add forces. This method returns the the time since the last frame update, meaning it will be bigger for low framerates and offset the lower number of force applications.


Global parameters created in a script which is attached to a GameObject will be modifiable from the inspector view of that GameObject. This is really handy for tuning physics variables, such as  "speed" coefficient for the Player sphere.



CAMERA

We want to make the camera follow the player sphere and rotate with it, in a typical third-person perspective. We could simply make the camera a child of the sphere in the object hierarchy. However because the player is a sphere which is rolling according to physics, the camera rolls with the sphere becoming extremely disorienting.

Instead, we will keep the camera independent of the sphere and use a script to make the camera follow the sphere's position. We need a public GameObject variable to set to the player sphere, and a private Vector3 offset to determine how far the camera sits from the sphere. First we will store the camera's starting transform into offset (in the "Start()" function), and then we will update that transform according to the player's position after every frame.

Inside the script, we can access the position of the camera's transform using "transform.position," and if we store the player GameObject in a variable "player", then we can access its position in "player.transform.position"

The above code should be placed in "LateUpdate()" which ensures our camera position is updated AFTER the physics engine has determined the sphere's new position. There are probably a lot of good reasons for this, but I can only speculate.


LEVEL DESIGN & PICKUPS

